ğŸ“ **ValidPalindrome**

---

ğŸ“„ Problem Statement
Given a string `s`, return `true` if it is a palindrome, or `false` otherwise.
A string is a palindrome when it reads the same forward and backward after converting all uppercase letters to lowercase and removing all non-alphanumeric characters.

---

ğŸ§ª Example 1
Input: `s = "A man, a plan, a canal: Panama"`
Output: `true`

ğŸ§ª Example 2
Input: `s = "race a car"`
Output: `false`

ğŸ§ª Example 3
Input: `s = " "`
Output: `true`

---

ğŸ“Œ Constraints

* `1 <= s.length <= 2 * 10^5`
* `s` consists only of printable ASCII characters.

---

âœ… Approach 1: String Filtering + Reversal

ğŸ§  Steps

1. Initialize a `StringBuilder` to collect all valid alphanumeric characters in lowercase.
2. Loop through each character of the input string `s`:
   â€ƒâ€ƒğŸ”¹ If the character is a letter or digit, convert it to lowercase and append to `StringBuilder`.
3. Convert the filtered result into a string and also reverse it.
4. Compare the filtered string and reversed string for equality.

ğŸ“¦ Code

```java
class Solution {
    public boolean isPalindrome(String s) {
        StringBuilder str = new StringBuilder();
        for (char ch : s.toCharArray()) {
            if (Character.isLetterOrDigit(ch)) {
                str.append(Character.toLowerCase(ch));
            }
        }
        String filtered = str.toString();
        String reversed = str.reverse().toString();
        return filtered.equals(reversed);
    }
}
```

âš¡ Time Complexity: O(n)
ğŸ“¦ Space Complexity: O(n)

---

âœ… Pros

* Straightforward to implement.
* Good readability and handles edge cases well.

âŒ Cons

* Additional space is used for the reversed string.
* Slightly less efficient due to duplication of data.

---

âœ… Approach 2: Two Pointer Without Extra Space

ğŸ§  Steps

1. Initialize two pointers: `left` at start and `right` at end of the string.
2. Move the pointers inward while skipping non-alphanumeric characters.
3. For each valid character at both ends, compare after converting to lowercase.
4. If at any point they donâ€™t match, return false.
5. If the entire string passes, return true.

ğŸ“¦ Code

```java
class Solution {
    public boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        while (left < right) {
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) left++;
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) right--;
            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

âš¡ Time Complexity: O(n)
ğŸ“¦ Space Complexity: O(1)

---

âœ… Pros

* Memory-efficient (no extra strings created).
* Better performance for large input.

âŒ Cons

* Slightly more complex logic than string reversal approach.

---

ğŸ†š Comparison Table

| Approach                 | Time Complexity | Space Complexity | Simplicity          | Efficiency       |
| ------------------------ | --------------- | ---------------- | ------------------- | ---------------- |
| Filter + Reverse (SB)    | O(n)            | O(n)             | âœ… Simple            | âŒ Less Efficient |
| Two Pointer Optimization | O(n)            | O(1)             | âš ï¸ Slightly Complex | âœ… More Efficient |
