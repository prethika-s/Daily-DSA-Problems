ğŸ“„ Problem Statement
Given a **1-indexed sorted array** of integers `numbers[]` and an integer `target`, return the indices of the **two numbers** such that they add up to `target`.

You must use only constant extra space and the solution must use the **two-pointer approach**.

---

ğŸ§ª Examples

âœ… Input: `numbers = [2, 7, 11, 15]`, `target = 9`
âœ… Output: `[1, 2]`
âœ… Explanation: `2 + 7 = 9`

âœ… Input: `numbers = [1, 2, 3, 4, 4, 9, 56, 90]`, `target = 8`
âœ… Output: `[4, 5]`

---

ğŸ“Œ Constraints

* `2 <= numbers.length <= 3 * 10â´`
* `-1000 <= numbers[i] <= 1000`
* `numbers` is sorted in **non-decreasing** order.
* `1 <= target <= 2000`
* Exactly **one solution** exists.

---

âš¡ Optimal Two-Pointer Approach

ğŸ§  Idea

* Start with two pointers: `first = 0` and `last = numbers.length - 1`
* Move pointers inward based on the sum compared to the target

  * If sum < target â†’ move `first` forward
  * If sum > target â†’ move `last` backward
  * If sum == target â†’ return the 1-indexed positions

ğŸ“¦ Code

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int[] result = new int[2];
        int first = 0;
        int last = numbers.length - 1;
        while (first < last) {
            int total = numbers[first] + numbers[last];
            if (total < target) {
                first++;
            } else if (total > target) {
                last--;
            } else {
                result[0] = first + 1;
                result[1] = last + 1;
                return result;
            }
        }
        return result;
    }
}
```

---

ğŸ“Š Complexity Analysis

| Metric              | Value |
| ------------------- | ----- |
| â±ï¸ Time Complexity  | O(n)  |
| ğŸ§  Space Complexity | O(1)  |

---

âœ… Pros

* Extremely efficient: linear time, constant space
* Simple logic using two-pointer technique
* Perfect for sorted arrays

âŒ Cons

* Only works when input is **sorted**
* Not reusable for unsorted arrays without preprocessing

---

ğŸ“Œ **Tip**: For **unsorted input**, use a **HashMap** to store seen values and check for complements in `O(n)` time with `O(n)` space.
